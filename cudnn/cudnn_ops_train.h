/*
 * Copyright 2014-2023 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO LICENSEE:
 *
 * This source code and/or documentation ("Licensed Deliverables") are
 * subject to NVIDIA intellectual property rights under U.S. and
 * international Copyright laws.
 *
 * These Licensed Deliverables contained herein is PROPRIETARY and
 * CONFIDENTIAL to NVIDIA and is being provided under the terms and
 * conditions of a form of NVIDIA software license agreement by and
 * between NVIDIA and Licensee ("License Agreement") or electronically
 * accepted by Licensee.  Notwithstanding any terms or conditions to
 * the contrary in the License Agreement, reproduction or disclosure
 * of the Licensed Deliverables to any third party without the express
 * written consent of NVIDIA is prohibited.
 *
 * NOTWITHSTANDING ANY TERMS OR CONDITIONS TO THE CONTRARY IN THE
 * LICENSE AGREEMENT, NVIDIA MAKES NO REPRESENTATION ABOUT THE
 * SUITABILITY OF THESE LICENSED DELIVERABLES FOR ANY PURPOSE.  IT IS
 * PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.
 * NVIDIA DISCLAIMS ALL WARRANTIES WITH REGARD TO THESE LICENSED
 * DELIVERABLES, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY,
 * NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * NOTWITHSTANDING ANY TERMS OR CONDITIONS TO THE CONTRARY IN THE
 * LICENSE AGREEMENT, IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY
 * SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THESE LICENSED DELIVERABLES.
 *
 * U.S. Government End Users.  These Licensed Deliverables are a
 * "commercial item" as that term is defined at 48 C.F.R. 2.101 (OCT
 * 1995), consisting of "commercial computer software" and "commercial
 * computer software documentation" as such terms are used in 48
 * C.F.R. 12.212 (SEPT 1995) and is provided to the U.S. Government
 * only as a commercial end item.  Consistent with 48 C.F.R.12.212 and
 * 48 C.F.R. 227.7202-1 through 227.7202-4 (JUNE 1995), all
 * U.S. Government End Users acquire the Licensed Deliverables with
 * only those rights set forth herein.
 *
 * Any use of the Licensed Deliverables in individual and commercial
 * software must include, in the user documentation and internal
 * comments to the code, the above Disclaimer and U.S. Government End
 * Users Notice.
 */

/*
 *  cudnn_ops_train : cuDNN's basic training operations and algorithms.
 */

#if !defined(CUDNN_OPS_TRAIN_H_)
#define CUDNN_OPS_TRAIN_H_

#include <sycl/sycl.hpp>
#include <dpct/dpct.hpp>
#include <stdint.h>

#include "cudnn_version.h"
#include "cudnn_ops_infer.h"

/* These version numbers are autogenerated, do not edit manually. */
#define CUDNN_OPS_TRAIN_MAJOR 8
#define CUDNN_OPS_TRAIN_MINOR 9
#define CUDNN_OPS_TRAIN_PATCH 1

#if (CUDNN_OPS_TRAIN_MAJOR != CUDNN_MAJOR) || (CUDNN_OPS_TRAIN_MINOR != CUDNN_MINOR) || \
    (CUDNN_OPS_TRAIN_PATCH != CUDNN_PATCHLEVEL)
#error Version mismatch in cuDNN OPS TRAIN!!!
#endif

#if defined(__cplusplus)
extern "C" {
#endif

/* Function to perform backward softmax */
dpct::err1 CUDNNWINAPI cudnnSoftmaxBackward(
    dpct::dnnl::engine_ext handle, dpct::dnnl::softmax_algorithm algo,
    dpct::dnnl::softmax_mode mode, const void *alpha,
    const dpct::dnnl::memory_desc_ext yDesc, const void *y,
    const dpct::dnnl::memory_desc_ext dyDesc, const void *dy, const void *beta,
    const dpct::dnnl::memory_desc_ext dxDesc, void *dx);

/* Function to perform backward pooling */
dpct::err1 CUDNNWINAPI cudnnPoolingBackward(
    dpct::dnnl::engine_ext handle, const dpct::dnnl::pooling_desc poolingDesc,
    const void *alpha, const dpct::dnnl::memory_desc_ext yDesc, const void *y,
    const dpct::dnnl::memory_desc_ext dyDesc, const void *dy,
    const dpct::dnnl::memory_desc_ext xDesc, const void *x, const void *beta,
    const dpct::dnnl::memory_desc_ext dxDesc, void *dx);

/* Function to perform backward activation  */
dpct::err1 CUDNNWINAPI cudnnActivationBackward(
    dpct::dnnl::engine_ext handle, dpct::dnnl::activation_desc activationDesc,
    const void *alpha, const dpct::dnnl::memory_desc_ext yDesc, const void *y,
    const dpct::dnnl::memory_desc_ext dyDesc, const void *dy,
    const dpct::dnnl::memory_desc_ext xDesc, const void *x, const void *beta,
    const dpct::dnnl::memory_desc_ext dxDesc, void *dx);

/* LRN cross-channel backward computation. Double parameters cast to tensor data type */
dpct::err1 CUDNNWINAPI cudnnLRNCrossChannelBackward(
    dpct::dnnl::engine_ext handle, dpct::dnnl::lrn_desc normDesc,
    dnnl::algorithm lrnMode, const void *alpha,
    const dpct::dnnl::memory_desc_ext yDesc, const void *y,
    const dpct::dnnl::memory_desc_ext dyDesc, const void *dy,
    const dpct::dnnl::memory_desc_ext xDesc, const void *x, const void *beta,
    const dpct::dnnl::memory_desc_ext dxDesc, void *dx);

dpct::err1 CUDNNWINAPI cudnnDivisiveNormalizationBackward(
    dpct::dnnl::engine_ext handle, dpct::dnnl::lrn_desc normDesc,
    cudnnDivNormMode_t mode, const void *alpha,
    const dpct::dnnl::memory_desc_ext
        xDesc, /* same desc for x, means, dy, temp, temp2 */
    const void *x,
    const void *means, /* if NULL, means are assumed to be zero */
    const void *dy, void *temp, void *temp2, const void *beta,
    const dpct::dnnl::memory_desc_ext
        dXdMeansDesc, /* same desc for dx, dMeans */
    void *dx,         /* output x differential */
    void *dMeans);    /* output means differential, can be NULL */

dpct::err1 CUDNNWINAPI cudnnGetBatchNormalizationForwardTrainingExWorkspaceSize(
    dpct::dnnl::engine_ext handle, dpct::dnnl::batch_normalization_mode mode,
    dpct::dnnl::batch_normalization_ops bnOps,
    const dpct::dnnl::memory_desc_ext xDesc,
    const dpct::dnnl::memory_desc_ext zDesc,
    const dpct::dnnl::memory_desc_ext yDesc,
    const dpct::dnnl::memory_desc_ext bnScaleBiasMeanVarDesc,
    const dpct::dnnl::activation_desc activationDesc, size_t *sizeInBytes);

dpct::err1 CUDNNWINAPI cudnnGetBatchNormalizationBackwardExWorkspaceSize(
    dpct::dnnl::engine_ext handle, dpct::dnnl::batch_normalization_mode mode,
    dpct::dnnl::batch_normalization_ops bnOps,
    const dpct::dnnl::memory_desc_ext xDesc,
    const dpct::dnnl::memory_desc_ext yDesc,
    const dpct::dnnl::memory_desc_ext dyDesc,
    const dpct::dnnl::memory_desc_ext dzDesc,
    const dpct::dnnl::memory_desc_ext dxDesc,
    const dpct::dnnl::memory_desc_ext dBnScaleBiasDesc,
    const dpct::dnnl::activation_desc activationDesc, size_t *sizeInBytes);

dpct::err1 CUDNNWINAPI cudnnGetBatchNormalizationTrainingExReserveSpaceSize(
    dpct::dnnl::engine_ext handle, dpct::dnnl::batch_normalization_mode mode,
    dpct::dnnl::batch_normalization_ops bnOps,
    const dpct::dnnl::activation_desc activationDesc,
    const dpct::dnnl::memory_desc_ext xDesc, size_t *sizeInBytes);

/* Computes y = BN(x). Also accumulates moving averages of mean and inverse variances */
dpct::err1 CUDNNWINAPI cudnnBatchNormalizationForwardTraining(
    dpct::dnnl::engine_ext handle, dpct::dnnl::batch_normalization_mode mode,

    const void *alpha, /* alpha[0] = result blend factor */
    const void *beta,  /* beta[0] = dest layer blend factor */

    const dpct::dnnl::memory_desc_ext xDesc, const void *x, /* NxCxHxW */
    const dpct::dnnl::memory_desc_ext yDesc, void *y,       /* NxCxHxW */

    /* Shared desc for the next 6 tensors in the argument list.
       Data type to be set as follows:
       type = (typeOf(x) == double) ? double : float
       Dimensions for this descriptor depend on normalization mode
       - Spatial Normalization : tensors are expected to have dims 1xCx1x1
        (normalization is performed across NxHxW)
       - Per-Activation Normalization : tensors are expected to have dims of
       1xCxHxW (normalization is performed across N) */
    const dpct::dnnl::memory_desc_ext bnScaleBiasMeanVarDesc,

    /* 'Gamma' and 'Beta' respectively in Ioffe and Szegedy's paper's notation
     */
    const void *bnScale, const void *bnBias,

    /* MUST use factor=1 in the very first call of a complete training cycle.
       Use a factor=1/(1+n) at N-th call to the function to get
       Cumulative Moving Average (CMA) behavior
       CMA[n] = (x[1]+...+x[n])/n
       Since CMA[n+1] = (n*CMA[n]+x[n+1])/(n+1) =
       ((n+1)*CMA[n]-CMA[n])/(n+1) + x[n+1]/(n+1) =
       CMA[n]*(1-1/(n+1)) + x[n+1]*1/(n+1) */
    double exponentialAverageFactor,

    /* Used in Training phase only.
       runningMean = newMean*factor + runningMean*(1-factor) */
    void *resultRunningMean,
    /* Output in training mode, input in inference. Is the moving average
       of  variance[x] (factor is applied in the same way as for runningMean) */
    void *resultRunningVariance,

    /* Has to be >= CUDNN_BN_MIN_EPSILON. Should be the same in forward and
       backward functions. */
    double epsilon,

    /* Optionally save intermediate results from the forward pass here
       - can be reused to speed up backward pass. NULL if unused */
    void *resultSaveMean, void *resultSaveInvVariance);

/* Computes y = relu(BN(x) + z). Also accumulates moving averages of mean and inverse variances */
dpct::err1 CUDNNWINAPI cudnnBatchNormalizationForwardTrainingEx(
    dpct::dnnl::engine_ext handle, dpct::dnnl::batch_normalization_mode mode,
    dpct::dnnl::batch_normalization_ops bnOps,

    const void *alpha, /* alpha[0] = result blend factor */
    const void *beta,  /* beta[0] = dest layer blend factor */

    const dpct::dnnl::memory_desc_ext xDesc, const void *xData,
    const dpct::dnnl::memory_desc_ext zDesc, const void *zData,
    const dpct::dnnl::memory_desc_ext yDesc, void *yData,

    const dpct::dnnl::memory_desc_ext bnScaleBiasMeanVarDesc,
    const void *bnScale, const void *bnBias,

    double exponentialAverageFactor, void *resultRunningMean,
    void *resultRunningVariance,

    /* Has to be >= CUDNN_BN_MIN_EPSILON. Should be the same in forward and
       backward functions. */
    double epsilon,

    /* Optionally save intermediate results from the forward pass here
       - can be reused to speed up backward pass. NULL if unused */
    void *resultSaveMean, void *resultSaveInvVariance,

    dpct::dnnl::activation_desc activationDesc, void *workspace,
    size_t workSpaceSizeInBytes, void *reserveSpace,
    size_t reserveSpaceSizeInBytes);

/* Performs backward pass of Batch Normalization layer. Returns x gradient,
* bnScale gradient and bnBias gradient */
dpct::err1 CUDNNWINAPI cudnnBatchNormalizationBackward(
    dpct::dnnl::engine_ext handle, dpct::dnnl::batch_normalization_mode mode,
    const void *alphaDataDiff, const void *betaDataDiff,
    const void *alphaParamDiff, const void *betaParamDiff,
    const dpct::dnnl::memory_desc_ext xDesc, /* same desc for x, dx, dy */
    const void *x, const dpct::dnnl::memory_desc_ext dyDesc, const void *dy,
    const dpct::dnnl::memory_desc_ext dxDesc, void *dx,
    /* Shared tensor desc for the 4 tensors below */
    const dpct::dnnl::memory_desc_ext dBnScaleBiasDesc,
    const void *bnScale, /* bnBias doesn't affect backpropagation */
    /* scale and bias diff are not backpropagated below this layer */
    void *dBnScaleResult, void *dBnBiasResult,
    /* Same epsilon as forward pass */
    double epsilon,

    /* Optionally cached intermediate results from
       forward pass */
    const void *savedMean, const void *savedInvVariance);

dpct::err1 CUDNNWINAPI cudnnBatchNormalizationBackwardEx(
    dpct::dnnl::engine_ext handle, dpct::dnnl::batch_normalization_mode mode,
    dpct::dnnl::batch_normalization_ops bnOps,

    const void *alphaDataDiff, const void *betaDataDiff,
    const void *alphaParamDiff, const void *betaParamDiff,
    const dpct::dnnl::memory_desc_ext xDesc, const void *xData,
    const dpct::dnnl::memory_desc_ext yDesc, const void *yData,
    const dpct::dnnl::memory_desc_ext dyDesc, const void *dyData,
    const dpct::dnnl::memory_desc_ext dzDesc, void *dzData,
    const dpct::dnnl::memory_desc_ext dxDesc, void *dxData,

    /* Shared tensor desc for the 4 tensors below */
    const dpct::dnnl::memory_desc_ext dBnScaleBiasDesc, const void *bnScaleData,
    const void *bnBiasData, /* needed if there is activation */
    void *dBnScaleData, void *dBnBiasData,
    double epsilon, /* Same epsilon as forward pass */

    /* Optionally cached intermediate results from
       forward pass */
    const void *savedMean, const void *savedInvVariance,
    dpct::dnnl::activation_desc activationDesc, void *workSpace,
    size_t workSpaceSizeInBytes, void *reserveSpace,
    size_t reserveSpaceSizeInBytes);

dpct::err1 CUDNNWINAPI cudnnGetNormalizationForwardTrainingWorkspaceSize(
    dpct::dnnl::engine_ext handle, dpct::dnnl::batch_normalization_mode mode,
    dpct::dnnl::batch_normalization_ops normOps, cudnnNormAlgo_t algo,
    const dpct::dnnl::memory_desc_ext xDesc,
    const dpct::dnnl::memory_desc_ext zDesc,
    const dpct::dnnl::memory_desc_ext yDesc,
    const dpct::dnnl::memory_desc_ext normScaleBiasDesc,
    const dpct::dnnl::activation_desc activationDesc,
    const dpct::dnnl::memory_desc_ext normMeanVarDesc, size_t *sizeInBytes,
    int groupCnt); /* Place hold for future work, should be set to 1 now*/

dpct::err1 CUDNNWINAPI cudnnGetNormalizationBackwardWorkspaceSize(
    dpct::dnnl::engine_ext handle, dpct::dnnl::batch_normalization_mode mode,
    dpct::dnnl::batch_normalization_ops normOps, cudnnNormAlgo_t algo,
    const dpct::dnnl::memory_desc_ext xDesc,
    const dpct::dnnl::memory_desc_ext yDesc,
    const dpct::dnnl::memory_desc_ext dyDesc,
    const dpct::dnnl::memory_desc_ext dzDesc,
    const dpct::dnnl::memory_desc_ext dxDesc,
    const dpct::dnnl::memory_desc_ext dNormScaleBiasDesc,
    const dpct::dnnl::activation_desc activationDesc,
    const dpct::dnnl::memory_desc_ext normMeanVarDesc, size_t *sizeInBytes,
    int groupCnt); /* Place hold for future work, should be set to 1 now*/

dpct::err1 CUDNNWINAPI cudnnGetNormalizationTrainingReserveSpaceSize(
    dpct::dnnl::engine_ext handle, dpct::dnnl::batch_normalization_mode mode,
    dpct::dnnl::batch_normalization_ops normOps, cudnnNormAlgo_t algo,
    const dpct::dnnl::activation_desc activationDesc,
    const dpct::dnnl::memory_desc_ext xDesc, size_t *sizeInBytes,
    int groupCnt); /* Place hold for future work, should be set to 1 now*/

/* Computes y = relu(Norm(x) + z). Also accumulates moving averages of mean and inverse variances */
dpct::err1 CUDNNWINAPI cudnnNormalizationForwardTraining(
    dpct::dnnl::engine_ext handle, dpct::dnnl::batch_normalization_mode mode,
    dpct::dnnl::batch_normalization_ops normOps, cudnnNormAlgo_t algo,
    const void *alpha, /* alpha[0] = result blend factor */
    const void *beta,  /* beta[0] = dest layer blend factor */
    const dpct::dnnl::memory_desc_ext xDesc, const void *xData,
    const dpct::dnnl::memory_desc_ext normScaleBiasDesc, const void *normScale,
    const void *normBias, double exponentialAverageFactor,
    const dpct::dnnl::memory_desc_ext normMeanVarDesc, void *resultRunningMean,
    void *resultRunningVariance,
    /* Has to be >= 0. Should be the same in forward and backward functions. */
    double epsilon,
    /* Optionally save intermediate results from the forward pass here
       - can be reused to speed up backward pass. NULL if unused */
    void *resultSaveMean, void *resultSaveInvVariance,
    dpct::dnnl::activation_desc activationDesc,
    const dpct::dnnl::memory_desc_ext zDesc, const void *zData,
    const dpct::dnnl::memory_desc_ext yDesc, void *yData, void *workspace,
    size_t workSpaceSizeInBytes, void *reserveSpace,
    size_t reserveSpaceSizeInBytes,
    int groupCnt); /* Place hold for future work, should be set to 1 now*/

dpct::err1 CUDNNWINAPI cudnnNormalizationBackward(
    dpct::dnnl::engine_ext handle, dpct::dnnl::batch_normalization_mode mode,
    dpct::dnnl::batch_normalization_ops normOps, cudnnNormAlgo_t algo,
    const void *alphaDataDiff, const void *betaDataDiff,
    const void *alphaParamDiff, const void *betaParamDiff,
    const dpct::dnnl::memory_desc_ext xDesc, const void *xData,
    const dpct::dnnl::memory_desc_ext yDesc, const void *yData,
    const dpct::dnnl::memory_desc_ext dyDesc, const void *dyData,
    const dpct::dnnl::memory_desc_ext dzDesc, void *dzData,
    const dpct::dnnl::memory_desc_ext dxDesc, void *dxData,
    /* Shared tensor desc for the 4 tensors below */
    const dpct::dnnl::memory_desc_ext dNormScaleBiasDesc,
    const void *normScaleData,
    const void *normBiasData, /* needed if there is activation */
    void *dNormScaleData, void *dNormBiasData,
    double epsilon, /* Same epsilon as forward pass */
    const dpct::dnnl::memory_desc_ext normMeanVarDesc,
    /* Optionally cached intermediate results from
       forward pass */
    const void *savedMean, const void *savedInvVariance,
    dpct::dnnl::activation_desc activationDesc, void *workSpace,
    size_t workSpaceSizeInBytes, void *reserveSpace,
    size_t reserveSpaceSizeInBytes,
    int groupCnt); /* Place hold for future work, should be set to 1 now*/

dpct::err1 CUDNNWINAPI cudnnSpatialTfGridGeneratorBackward(
    dpct::dnnl::engine_ext handle,
    const cudnnSpatialTransformerDescriptor_t stDesc, const void *dgrid,
    void *dtheta);

dpct::err1 CUDNNWINAPI cudnnSpatialTfSamplerBackward(
    dpct::dnnl::engine_ext handle, cudnnSpatialTransformerDescriptor_t stDesc,
    const void *alpha, const dpct::dnnl::memory_desc_ext xDesc, const void *x,
    const void *beta, const dpct::dnnl::memory_desc_ext dxDesc, void *dx,
    const void *alphaDgrid, const dpct::dnnl::memory_desc_ext dyDesc,
    const void *dy, const void *grid, const void *betaDgrid, void *dgrid);

dpct::err1 CUDNNWINAPI cudnnDropoutBackward(
    dpct::dnnl::engine_ext handle, const cudnnDropoutDescriptor_t dropoutDesc,
    const dpct::dnnl::memory_desc_ext dydesc, const void *dy,
    const dpct::dnnl::memory_desc_ext dxdesc, void *dx, void *reserveSpace,
    size_t reserveSpaceSizeInBytes);

/*
 * \brief Cross-library version checker.
 * This function is implemented differently in each sub-library. Each sublib
 * checks whether its own version matches that of its dependencies.
 * \returns CUDNN_STATUS_SUCCESS if the version check passes,
 *          CUDNN_STATUS_VERSION_MISMATCH if the versions are inconsistent.
 */
dpct::err1 CUDNNWINAPI cudnnOpsTrainVersionCheck(void);

#if defined(__cplusplus)
}
#endif

#endif /* CUDNN_OPS_TRAIN_H_ */
